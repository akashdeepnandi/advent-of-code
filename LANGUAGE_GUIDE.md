| Task / Need                | 🐍 Python                        | 🦀 Rust                                 | ☕ JS (Node/ES)                                    | 🦫 Go                                 | ⚡ C++                                                              |
| -------------------------- | -------------------------------- | --------------------------------------- | ------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------ |
| **Input lines**            | `open("in").read().splitlines()` | `include_str!("in").lines()`            | `fs.readFileSync("in","utf8").trim().split("\n")` | `bufio.Scanner` + `scanner.Text()`    | `ifstream >> line` + `getline`                                     |
| **String split**           | `s.split()` / `s.split(",")`     | `s.split_whitespace()` / `s.split(",")` | `s.split(" ")`, `s.split(",")`                    | `strings.Split(s, ",")`               | `stringstream ss(s); getline(ss, part, ',')`                       |
| **Trim**                   | `s.strip()`                      | `s.trim()`                              | `s.trim()`                                        | `strings.TrimSpace(s)`                | manual: `erase/remove_if` or `isspace`                             |
| **Substr / slice**         | `s[i:j]`                         | `&s[i..j]` (careful UTF-8)              | `s.slice(i,j)`                                    | `s[i:j]` (bytes, careful UTF-8)       | `s.substr(i, len)`                                                 |
| **Char loop**              | `for c in s:`                    | `for c in s.chars()`                    | `for (const c of s)`                              | `for _, r := range s` (runes)         | `for (char c : s)`                                                 |
| **Lists / arrays**         | `list`                           | `Vec<T>`                                | `Array`                                           | `[]T` slice                           | `vector<T>`                                                        |
| **Set**                    | `set()`                          | `HashSet<T>`                            | `new Set()`                                       | `map[T]struct{}`                      | `unordered_set<T>`                                                 |
| **Map / dict**             | `dict()`                         | `HashMap<K,V>`                          | `new Map()`, `{}`                                 | `map[K]V`                             | `unordered_map<K,V>`                                               |
| **Queue (BFS)**            | `collections.deque`              | `VecDeque`                              | `[]` with push/shift                              | `[]T` or `container/list`             | `queue<T>`                                                         |
| **Stack (DFS)**            | list `.append/.pop`              | `Vec` push/pop                          | `[]` push/pop                                     | `[]T` append/pop                      | `stack<T>`                                                         |
| **Sorting**                | `sorted(arr)`                    | `arr.sort()`                            | `arr.sort((a,b)=>a-b)`                            | `sort.Ints(arr)` / `sort.Slice`       | `sort(arr.begin(), arr.end())`                                     |
| **Min/max**                | `min(arr)`, `max(arr)`           | `iter.min()`, `iter.max()`              | `Math.min(...arr)`                                | manual loop / `slices.Min` (Go 1.21+) | `*min_element`, `*max_element`                                     |
| **Sum**                    | `sum(arr)`                       | `iter.sum()`                            | `arr.reduce((a,b)=>a+b)`                          | manual loop                           | `accumulate(v.begin(), v.end(), 0)`                                |
| **Enumerate / index loop** | `for i,v in enumerate(arr)`      | `.iter().enumerate()`                   | `arr.forEach((v,i)=>…)`                           | `for i,v := range arr`                | `for (int i=0; i<n; i++)` or `for (auto [i,v]: enumerate)` (C++23) |
| **Comprehension / map**    | `[f(x) for x in arr]`            | `.iter().map(f).collect()`              | `arr.map(f)`                                      | explicit `for` → append               | `transform(arr.begin(),arr.end(),out.begin(),f)`                   |
| **Filter**                 | `[x for x in arr if cond]`       | `.iter().filter(cond).collect()`        | `arr.filter(cond)`                                | explicit `for` → append if cond       | `copy_if`                                                          |
| **Any / All**              | `any(cond(x) for x in arr)`      | `.iter().any(cond)`, `.all(cond)`       | `arr.some(cond)`, `arr.every(cond)`               | loop check                            | manual loop / `all_of`, `any_of`                                   |
| **Grid (2D)**              | list of lists                    | `Vec<Vec<T>>`                           | `Array<Array<T>>`                                 | `[][]T` slices                        | `vector<vector<T>>`                                                |
| **Graph repr.**            | `dict[u][v] = w`                 | `HashMap<Node, HashMap<Node,w>>`        | `{u:{v:w}}` or `Map` of Maps                      | `map[string]map[string]int`           | `unordered_map<string,unordered_map<string,int>>`                  |
| **Permutation / combos**   | (Write own recursion)            | (Write own recursion)                   | (Write own recursion)                             | (Write own recursion)                 | (Write own recursion, don’t use `next_permutation`)                |
| **Debug print**            | `print(x)`                       | `dbg!(x)` or `println!("{:?}", x)`      | `console.log(x)`                                  | `fmt.Println(x)`                      | `cout << x`                                                        |

