| Task / Need                | 🐍 Python                        | 🦀 Rust                                 | ☕ JS (Node/ES)                                    | 🦫 Go                                 | ⚡ C++                                                              |
| -------------------------- | -------------------------------- | --------------------------------------- | ------------------------------------------------- | ------------------------------------- | ------------------------------------------------------------------ |
| **Input lines**            | `open("in").read().splitlines()` | `include_str!("in").lines()`            | `fs.readFileSync("in","utf8").trim().split("\n")` | `bufio.Scanner` + `scanner.Text()`    | `ifstream >> line` + `getline`                                     |
| **String split**           | `s.split()` / `s.split(",")`     | `s.split_whitespace()` / `s.split(",")` | `s.split(" ")`, `s.split(",")`                    | `strings.Split(s, ",")`               | `stringstream ss(s); getline(ss, part, ',')`                       |
| **Trim**                   | `s.strip()`                      | `s.trim()`                              | `s.trim()`                                        | `strings.TrimSpace(s)`                | manual: `erase/remove_if` or `isspace`                             |
| **Substr / slice**         | `s[i:j]`                         | `&s[i..j]` (careful UTF-8)              | `s.slice(i,j)`                                    | `s[i:j]` (bytes, careful UTF-8)       | `s.substr(i, len)`                                                 |
| **Char loop**              | `for c in s:`                    | `for c in s.chars()`                    | `for (const c of s)`                              | `for _, r := range s` (runes)         | `for (char c : s)`                                                 |
| **Lists / arrays**         | `list`                           | `Vec<T>`                                | `Array`                                           | `[]T` slice                           | `vector<T>`                                                        |
| **Set**                    | `set()`                          | `HashSet<T>`                            | `new Set()`                                       | `map[T]struct{}`                      | `unordered_set<T>`                                                 |
| **Map / dict**             | `dict()`                         | `HashMap<K,V>`                          | `new Map()`, `{}`                                 | `map[K]V`                             | `unordered_map<K,V>`                                               |
| **Queue (BFS)**            | `collections.deque`              | `VecDeque`                              | `[]` with push/shift                              | `[]T` or `container/list`             | `queue<T>`                                                         |
| **Stack (DFS)**            | list `.append/.pop`              | `Vec` push/pop                          | `[]` push/pop                                     | `[]T` append/pop                      | `stack<T>`                                                         |
| **Sorting**                | `sorted(arr)`                    | `arr.sort()`                            | `arr.sort((a,b)=>a-b)`                            | `sort.Ints(arr)` / `sort.Slice`       | `sort(arr.begin(), arr.end())`                                     |
| **Min/max**                | `min(arr)`, `max(arr)`           | `iter.min()`, `iter.max()`              | `Math.min(...arr)`                                | manual loop / `slices.Min` (Go 1.21+) | `*min_element`, `*max_element`                                     |
| **Sum**                    | `sum(arr)`                       | `iter.sum()`                            | `arr.reduce((a,b)=>a+b)`                          | manual loop                           | `accumulate(v.begin(), v.end(), 0)`                                |
| **Enumerate / index loop** | `for i,v in enumerate(arr)`      | `.iter().enumerate()`                   | `arr.forEach((v,i)=>…)`                           | `for i,v := range arr`                | `for (int i=0; i<n; i++)` or `for (auto [i,v]: enumerate)` (C++23) |
| **Comprehension / map**    | `[f(x) for x in arr]`            | `.iter().map(f).collect()`              | `arr.map(f)`                                      | explicit `for` → append               | `transform(arr.begin(),arr.end(),out.begin(),f)`                   |
| **Filter**                 | `[x for x in arr if cond]`       | `.iter().filter(cond).collect()`        | `arr.filter(cond)`                                | explicit `for` → append if cond       | `copy_if`                                                          |
| **Any / All**              | `any(cond(x) for x in arr)`      | `.iter().any(cond)`, `.all(cond)`       | `arr.some(cond)`, `arr.every(cond)`               | loop check                            | manual loop / `all_of`, `any_of`                                   |
| **Grid (2D)**              | list of lists                    | `Vec<Vec<T>>`                           | `Array<Array<T>>`                                 | `[][]T` slices                        | `vector<vector<T>>`                                                |
| **Graph repr.**            | `dict[u][v] = w`                 | `HashMap<Node, HashMap<Node,w>>`        | `{u:{v:w}}` or `Map` of Maps                      | `map[string]map[string]int`           | `unordered_map<string,unordered_map<string,int>>`                  |
| **Permutation / combos**   | (Write own recursion)            | (Write own recursion)                   | (Write own recursion)                             | (Write own recursion)                 | (Write own recursion, don’t use `next_permutation`)                |
| **Debug print**            | `print(x)`                       | `dbg!(x)` or `println!("{:?}", x)`      | `console.log(x)`                                  | `fmt.Println(x)`                      | `cout << x`                                                        |


# RUST String types

| Type                 |                                                                                                                                                            What / short description | Key differences from others                                                                                                                                                    | Use-case + tiny example                                                                                                                                                                                                    |
| -------------------- | ----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------: | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------ | -------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
| `&str`               |                                                                               Borrowed string slice — a view into UTF-8 text (often `&'a str`, string literals are `&'static str`). | Borrowed, not owned; no heap allocation by itself; immutable (unless `&mut str`). Use for function arguments when you don't need ownership. ([Rust Documentation][1])          | `rust\nfn greet(name: &str){ println!(\"Hello, {}\", name); }\nlet s: &str = \"world\"; greet(s);\n`                                                                                                                       |
| `String`             |                                                                              Owned, growable, heap-allocated UTF-8 string. Most common owned string type. ([Rust Documentation][2]) | Owns data (can be mutated, pushed to, moved). Conversions: `&str` → `String` (`to_string()` / `String::from`) and `String` → `&str` (via `&s`).                                | `rust\nlet mut s = String::from(\"hi\");\ns.push_str(\", there\");\nprintln!(\"{}\", s);\n`                                                                                                                                |
| `Cow<'a, str>`       | Clone-On-Write wrapper that can be either borrowed (`&'a str`) or owned (`String`). Good for APIs that accept borrowed or owned text with minimal copies. ([Rust Documentation][3]) | Avoids cloning unless you need ownership/mutation. Useful when you want a single API type that can be cheaply constructed from either `&str` or `String`.                      | `rust\nuse std::borrow::Cow;\nfn normalize_name(input: Cow<'_, str>){\n  let mut owned = input.into_owned();\n  owned.make_ascii_lowercase();\n  println!(\"{}\", owned);\n}\nnormalize_name(Cow::Borrowed(\"ALICE\"));\n` |
| `Box<str>`           |                        Heap-allocated **owned** `str` (a boxed string slice). Smaller metadata than `String` when you only need an immutable heap string. ([Rust Documentation][4]) | Like `String` but immutable and sometimes slightly smaller (fewer usize fields). Good for long-lived immutable text where you want to avoid the 3-usize `String` header.       | `rust\nlet s = String::from(\"big, static text\");\nlet boxed: Box<str> = s.into_boxed_str();\n// boxed is an owned heap str (immutable)\n`                                                                                |
| `OsStr` / `OsString` |                    Platform-native strings (may be non-UTF8 on some OSes). Use for file paths, environment variables, CLI args where OS encoding matters. ([Rust Documentation][5]) | Can represent non-UTF8 bytes that `str`/`String` cannot. Conversions to `String` may be lossy (`to_string_lossy`). Use for OS/FS/argv interop.                                 | `rust\nuse std::ffi::OsString;\nlet path: OsString = OsString::from(\"/tmp/foo\");\nprintln!(\"{}\", path.to_string_lossy());\n`                                                                                           |
| `CStr` / `CString`   |        C-compatible NUL-terminated strings for FFI. `CString` = owned, `&CStr` = borrowed. Must not contain interior NUL bytes when creating a `CString`. ([Rust Documentation][6]) | Required for calling C APIs (pass `as_ptr()`), enforces NUL-termination and checks for interior NULs on construction. Not interchangeable with `String` without conversion.    | `rust\nuse std::ffi::CString;\nlet c = CString::new(\"hello\").unwrap();\n// pass c.as_ptr() to C; to read back: unsafe { CStr::from_ptr(ptr) }\n`                                                                         |
| `Vec<u8>`            |                                                                             Raw bytes buffer — used when input may not be UTF-8 (binary protocols, encodings, network, file reads). | No UTF-8 guarantee. Use for binary data or when you must handle arbitrary bytes; can convert to `String` with `String::from_utf8` (which validates). ([Rust Documentation][7]) | `rust\nlet bytes: Vec<u8> = std::fs::read(\"file.bin\").unwrap();\nif let Ok(s) = String::from_utf8(bytes){ println!(\"utf8: {}\", s); }\n`                                                                                |

[1]: https://doc.rust-lang.org/std/primitive.str.html?utm_source=chatgpt.com "str"
[2]: https://doc.rust-lang.org/std/string/struct.String.html?utm_source=chatgpt.com "String in std"
[3]: https://doc.rust-lang.org/std/borrow/enum.Cow.html?utm_source=chatgpt.com "Cow in std::borrow"
[4]: https://doc.rust-lang.org/std/boxed/struct.Box.html?utm_source=chatgpt.com "Box in std"
[5]: https://doc.rust-lang.org/std/ffi/os_str/struct.OsStr.html?utm_source=chatgpt.com "OsStr in std::ffi::os_str"
[6]: https://doc.rust-lang.org/std/ffi/struct.CString.html?utm_source=chatgpt.com "CString in std::ffi"
[7]: https://doc.rust-lang.org/rust-by-example/std/str.html?utm_source=chatgpt.com "Strings - Rust By Example"

